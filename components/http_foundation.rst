.. index::
   single: HTTP
   single: HttpFoundation

The HttpFoundation Component
============================

    The HttpFoundation Component defines an object-oriented layer for the HTTP
    specification.

In PHP, the request is represented by some global variables (``$_GET``,
``$_POST``, ``$_FILE``, ``$_COOKIE``, ``$_SESSION``...) and the response is
generated by some functions (``echo``, ``header``, ``setcookie``, ...).

The Symfony2 HttpFoundation component replaces these default PHP global
variables and functions by an Object-Oriented layer.

Installation
------------

You can install the component in many different ways:

* Use the official Git repository (https://github.com/symfony/HttpFoundation);
* Install it via PEAR ( `pear.symfony.com/HttpFoundation`);
* Install it via Composer (`symfony/http-foundation` on Packagist).

Request
-------

The most common way to create request is to base it on the current PHP global
variables with
:method:`Symfony\\Component\\HttpFoundation\\Request::createFromGlobals`::

    use Symfony\Component\HttpFoundation\Request;

    $request = Request::createFromGlobals();

which is almost equivalent to the more verbose, but also more flexible,
:method:`Symfony\\Component\\HttpFoundation\\Request::__construct` call::

    $request = new Request($_GET, $_POST, array(), $_COOKIE, $_FILES, $_SERVER);

Accessing Request Data
~~~~~~~~~~~~~~~~~~~~~~

A Request object holds information about the client request. This information
can be accessed via several public properties:

* ``request``: equivalent of ``$_POST``;

* ``query``: equivalent of ``$_GET`` (``$request->query->get('name')``);

* ``cookies``: equivalent of ``$_COOKIE``;

* ``attributes``: no equivalent - used by your app to store other data (see :ref:`below<component-foundation-attributes>`)

* ``files``: equivalent of ``$_FILE``;

* ``server``: equivalent of ``$_SERVER``;

* ``headers``: mostly equivalent to a sub-set of ``$_SERVER``
  (``$request->headers->get('Content-Type')``).

Each property is a :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`
instance (or a sub-class of), which is a data holder class:

* ``request``: :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`;

* ``query``:   :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`;

* ``cookies``: :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`;

* ``attributes``: :class:`Symfony\\Component\\HttpFoundation\\ParameterBag`;

* ``files``:   :class:`Symfony\\Component\\HttpFoundation\\FileBag`;

* ``server``:  :class:`Symfony\\Component\\HttpFoundation\\ServerBag`;

* ``headers``: :class:`Symfony\\Component\\HttpFoundation\\HeaderBag`.

All :class:`Symfony\\Component\\HttpFoundation\\ParameterBag` instances have
methods to retrieve and update its data:

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::all`: Returns
  the parameters;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::keys`: Returns
  the parameter keys;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::replace`:
  Replaces the current parameters by a new set;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::add`: Adds
  parameters;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::get`: Returns a
  parameter by name;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::set`: Sets a
  parameter by name;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::has`: Returns
  true if the parameter is defined;

* :method:`Symfony\\Component\\HttpFoundation\\ParameterBag::remove`: Removes
  a parameter.

The :class:`Symfony\\Component\\HttpFoundation\\ParameterBag` instance also
has some methods to filter the input values:

* :method:`Symfony\\Component\\HttpFoundation\\Request::getAlpha`: Returns
  the alphabetic characters of the parameter value;

* :method:`Symfony\\Component\\HttpFoundation\\Request::getAlnum`: Returns
  the alphabetic characters and digits of the parameter value;

* :method:`Symfony\\Component\\HttpFoundation\\Request::getDigits`: Returns
  the digits of the parameter value;

* :method:`Symfony\\Component\\HttpFoundation\\Request::getInt`: Returns the
  parameter value converted to integer;

* :method:`Symfony\\Component\\HttpFoundation\\Request::filter`: Filters the
  parameter by using the PHP ``filter_var()`` function.

All getters takes up to three arguments: the first one is the parameter name
and the second one is the default value to return if the parameter does not
exist::

    // the query string is '?foo=bar'

    $request->query->get('foo');
    // returns bar

    $request->query->get('bar');
    // returns null

    $request->query->get('bar', 'bar');
    // returns 'bar'


When PHP imports the request query, it handles request parameters like
``foo[bar]=bar`` in a special way as it creates an array. So you can get the
``foo`` parameter and you will get back an array with a ``bar`` element. But
sometimes, you might want to get the value for the "original" parameter name:
``foo[bar]``. This is possible with all the `ParameterBag` getters like
:method:`Symfony\\Component\\HttpFoundation\\Request::get` via the third
argument::

        // the query string is '?foo[bar]=bar'

        $request->query->get('foo');
        // returns array('bar' => 'bar')

        $request->query->get('foo[bar]');
        // returns null

        $request->query->get('foo[bar]', null, true);
        // returns 'bar'

.. _component-foundation-attributes:

Last, but not the least, you can also store additional data in the request,
thanks to the ``attributes`` public property, which is also an instance of
:class:`Symfony\\Component\\HttpFoundation\\ParameterBag`. This is mostly used
to attach information that belongs to the Request and that needs to be
accessed from many different points in your application. For information
on how this is used in the Symfony2 framework, see :ref:`read more<book-fundamentals-attributes>`.

Identifying a Request
~~~~~~~~~~~~~~~~~~~~~

In your application, you need a way to identify a request; most of the time,
this is done via the "path info" of the request, which can be accessed via the
:method:`Symfony\\Component\\HttpFoundation\\Request::getPathInfo` method::

    // for a request to http://example.com/blog/index.php/post/hello-world
    // the path info is "/post/hello-world"
    $request->getPathInfo();

Simulating a Request
~~~~~~~~~~~~~~~~~~~~

Instead of creating a Request based on the PHP globals, you can also simulate
a Request::

    $request = Request::create('/hello-world', 'GET', array('name' => 'Fabien'));

The :method:`Symfony\\Component\\HttpFoundation\\Request::create` method
creates a request based on a path info, a method and some parameters (the
query parameters or the request ones depending on the HTTP method); and of
course, you an also override all other variables as well (by default, Symfony
creates sensible defaults for all the PHP global variables).

Based on such a request, you can override the PHP global variables via
:method:`Symfony\\Component\\HttpFoundation\\Request::overrideGlobals`::

    $request->overrideGlobals();

.. tip::

    You can also duplicate an existing query via
    :method:`Symfony\\Component\\HttpFoundation\\Request::duplicate` or
    change a bunch of parameters with a single call to
    :method:`Symfony\\Component\\HttpFoundation\\Request::initialize`.

Accessing the Session
~~~~~~~~~~~~~~~~~~~~~

If you have a session attached to the Request, you can access it via the
:method:`Symfony\\Component\\HttpFoundation\\Request::getSession` method;
the
:method:`Symfony\\Component\\HttpFoundation\\Request::hasPreviousSession`
method tells you if the request contains a Session which was started in one of
the previous requests.

Accessing other Data
~~~~~~~~~~~~~~~~~~~~

The Request class has many other methods that you can use to access the
request information. Have a look at the API for more information about them.

Response
--------

A :class:`Symfony\\Component\\HttpFoundation\\Response` object holds all the
information that needs to be sent back to the client from a given request. The
constructor takes up to three arguments: the response content, the status
code, and an array of HTTP headers::

    use Symfony\Component\HttpFoundation\Response;

    $response = new Response('Content', 200, array('content-type' => 'text/html'));

These information can also be manipulated after the Response object creation::

    $response->setContent('Hello World');

    // the headers public attribute is a ResponseHeaderBag
    $response->headers->set('Content-Type', 'text/plain');

    $response->setStatusCode(404);

When setting the ``Content-Type`` of the Response, you can set the charset,
but it is better to set it via the
:method:`Symfony\\Component\\HttpFoundation\\Response::setCharset` method::

    $response->setCharset('ISO-8859-1');

Note that by default, Symfony assumes that your Responses are encoded in
UTF-8.

Sending the Response
~~~~~~~~~~~~~~~~~~~~

Before sending the Response, you can ensure that it is compliant with the HTTP
specification by calling the
:method:`Symfony\\Component\\HttpFoundation\\Response::prepare` method::

    $response->prepare($request);

Sending the response to the client is then as simple as calling
:method:`Symfony\\Component\\HttpFoundation\\Response::send`::

    $response->send();

Setting Cookies
~~~~~~~~~~~~~~~

The response cookies can be manipulated though the ``headers`` public
attribute::

    use Symfony\Component\HttpFoundation\Cookie;

    $response->headers->setCookie(new Cookie('foo', 'bar'));

The
:method:`Symfony\\Component\\HttpFoundation\\ResponseHeaderBag::setCookie`
method takes an instance of
:class:`Symfony\\Component\\HttpFoundation\\Cookie` as an argument.

You can clear a cookie via the
:method:`Symfony\\Component\\HttpFoundation\\Response::clearCookie` method.

Managing the HTTP Cache
~~~~~~~~~~~~~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpFoundation\\Response` class has a rich set
of methods to manipulate the HTTP headers related to the cache:

* :method:`Symfony\\Component\\HttpFoundation\\Response::setPublic`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setPrivate`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::expire`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setExpires`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setMaxAge`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setSharedMaxAge`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setTtl`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setClientTtl`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setLastModified`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setEtag`;
* :method:`Symfony\\Component\\HttpFoundation\\Response::setVary`;

The :method:`Symfony\\Component\\HttpFoundation\\Response::setCache` method
can be used to set the most commonly used cache information in one method
call::

    $response->setCache(array(
        'etag'          => 'abcdef',
        'last_modified' => new \DateTime(),
        'max_age'       => 600,
        's_maxage'      => 600,
        'private'       => false,
        'public'        => true,
    ));

To check if the Response validators (``ETag``, ``Last-Modified``) match a
conditional value specified in the client Request, use the
:method:`Symfony\\Component\\HttpFoundation\\Response::isNotModified`
method::

    if ($response->isNotModified($request)) {
        $response->send();
    }

If the Response is not modified, it sets the status code to 304 and remove the
actual response content.

Redirecting the User
~~~~~~~~~~~~~~~~~~~~

To redirect the client to another URL, you can use the
:class:`Symfony\\Component\\HttpFoundation\\RedirectResponse` class::

    use Symfony\Component\HttpFoundation\RedirectResponse;

    $response = new RedirectResponse('http://example.com/');

Streaming a Response
~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 2.1
    Support for streamed responses was added in Symfony 2.1.

The :class:`Symfony\\Component\\HttpFoundation\\StreamedResponse` class allows
you to stream the Response back to the client. The response content is
represented by a PHP callable instead of a string::

    use Symfony\Component\HttpFoundation\StreamedResponse;

    $response = new StreamedResponse();
    $response->setCallback(function () {
        echo 'Hello World';
        flush();
        sleep(2);
        echo 'Hello World';
        flush();
    });
    $response->send();

Downloading Files
~~~~~~~~~~~~~~~~~

.. versionadded:: 2.1
    The ``makeDisposition`` method was added in Symfony 2.1.

When uploading a file, you must add a ``Content-Disposition`` header to your
response. While creating this header for basic file downloads is easy, using
non-ASCII filenames is more involving. The
:method:`:Symfony\\Component\\HttpFoundation\\Response:makeDisposition`
abstracts the hard work behind a simple API::

    use Symfony\Component\HttpFoundation\ResponseHeaderBag;

    $d = $response->headers->makeDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, 'foo.pdf');

    $response->headers->set('Content-Disposition', $d);

Session
-------

The Symfony2 HttpFoundation Component has a very powerful and flexible session
subsystem which is designed to provide session management through a simple
object-oriented interface using a variety of session storage drivers.

.. versionadded:: 2.1
    The :class:`Symfony\\Component\\HttpFoundation\\Session\\SessionInterface` interface,
    as well as a number of other changes, are new as of Symfony 2.1.

Sessions are used via the simple :class:`Symfony\\Component\\HttpFoundation\\Session\\Session`
implementation of :class:`Symfony\\Component\\HttpFoundation\\Session\\SessionInterface` interface.

Quick example::

    use Symfony\\Component\\HttpFoundation\\Session\\Session;

    $session = new Session();
    $session->start();

    // set and get session attributes
    $session->set('name', 'Drak');
    $session->get('name');

    // set and retrieve flash messages
    $session->getFlashBag()->set('notice', 'Profile updated');

    echo $session->getFlashBag()->get('notice');

Session API
~~~~~~~~~~~

The :class:`Symfony\\Component\\HttpFoundation\\Session\\Session` class implements
:class:`Symfony\\Component\\HttpFoundation\\Session\\SessionInterface`.

The :class:`Symfony\\Component\\HttpFoundation\\Session\\Session` has a simple API
as follows divided into a couple of groups.

Session workflow

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::start`:
  Starts the session - do not use ``session_start()``.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::migrate`:
  Regenerates the session id - do not use ``session_regenerate_id()``.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::invalidate`:
  Clears the session data and regenerates the session id do not use ``session_destroy()``.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::getId`: Gets the
  session ID.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::setId`: Sets the
  session ID.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::getName`: Gets the
  session name.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::setName`: Sets the
  session name.

Session attributes

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::set`:
  Sets an attribute by key;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::get`:
  Gets an attribute by key;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::all`:
  Gets all attributes as an array of key => value;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::has`:
  Returns true if the attribute exists;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::keys`:
  Returns an array of stored attribute keys;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::replace`:
  Sets multiple attributes at once: takes a keyed array and sets each key => value pair.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::remove`:
  Deletes an attribute by key;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::clear`:
  Clear all attributes;

The attributes are stored internally in an "Bag", a PHP object that acts like
an array. A few methods exist for "Bag" management:

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::registerBag`:
  Registers a :class:`Symfony\\Component\\HttpFoundation\\Session\\SessionBagInterface`

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::getBag`:
  Gets a :class:`Symfony\\Component\\HttpFoundation\\Session\\SessionBagInterface` by
  bag name.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Session::getFlashBag`:
  Gets the :class:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface`.
  This is just a shortcut for convenience.

Save Handlers
~~~~~~~~~~~~~

The PHP session workflow has 6 possible operations that may occur.  The normal
session follows `open`, `read`, `write` and `close`, with the possibility of
`destroy` and `gc` (garbage collection which will expire any old sessions: `gc`
is called randomly according to PHP's configuration and if called, it is invoked
after the `open` operation).  You can read more about this at
`php.net/session.customhandler`_


Native PHP Save Handlers
~~~~~~~~~~~~~~~~~~~~~~~~

So-called 'native' handlers, are session handlers which are either compiled into
PHP or provided by PHP extensions, such as PHP-Sqlite, PHP-Memcached and so on.
The handlers are compiled and can be activated directly in PHP using
`ini_set('session.save_handler', $name);` and are usually configured with
`ini_set('session.save_path', $path);` and sometimes, a variety of other PHP
`ini` directives.

Symfony2 provides drivers for native handlers which are easy to configure, these are:

  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeFileSessionHandler`;
  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeSqliteSessionHandler`;
  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeMemcacheSessionHandler`;
  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeMemcachedSessionHandler`;

Example of use::

    use Symfony\\Component\\HttpFoundation\\Session\\Session;
    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage;
    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeMemcachedSessionHandler;

    $storage = new NativeSessionStorage(array(), new NativeMemcachedSessionHandler());
    $session = new Session($storage);

Custom Save Handlers
~~~~~~~~~~~~~~~~~~~~

Custom handlers are those which completely replace PHP's built in session save
handlers by providing six callback functions which PHP calls internally at
various points in the session workflow.

Symfony2 HttpFoundation provides some by default and these can easily serve as
examples if you wish to write your own.

  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler`;
  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MemcacheSessionHandler`;
  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\MemcachedSessionHandler`;
  * :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NullSessionHandler`;

Example::

    use Symfony\\Component\\HttpFoundation\\Session\\Session;
    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\SessionStorage;
    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\PdoSessionHandler;

    $storage = new NativeSessionStorage(array(), new PdoSessionHandler());
    $session = new Session($storage);

Session Bags
------------

PHP's session management requires the use of the `$_SESSION` super-global,
however, this interferes somewhat with code testability and encapsulation in a
OOP paradigm. To help overcome this, Symfony2 uses 'session bags' linked to the
session to encapsulate a specific dataset of 'attributes' or 'flash messages'.

This approach also mitigates namespace pollution within the `$_SESSION`
super-global because each bag stores all its data under a unique namespace.
This allows Symfony2 to peacefully co-exist with other applications or libraries
that might use the `$_SESSION` super-global and all data remains completely
compatible with Symfony2's session management.

Symfony2 provides 2 kinds of bags, with two separate implementations.
Everything is written against interfaces so you may extend or create your own
bag types if necessary.

:class:`Symfony\\Component\\HttpFoundation\\Session\\SessionBagInterface` has
the following API which is intended mainly for internal purposes:

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionBagInterface::getStorageKey`:
  Returns the key which the bag will ultimately store its array under in `$_SESSION`.
  Generally this value can be left at its default and is for internal use.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionBagInterface::initialize`:
  This is called internally by Symfony2 session storage classes to link bag data
  to the session.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionBagInterface::getName`:
  Returns the name of the session bag.

Attributes
~~~~~~~~~~

The purpose of the bags implementing the :class:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface`
is to handle session attribute storage. This might include things like user ID,
and remember me login settings or other user based state information.

* :class:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBag`
  This is the standard default implementation.

* :class:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\NamespacedAttributeBag`
  This implementation allows for attributes to be stored in a structured namespace.

Any plain `key => value` storage system is limited in the extent to which
complex data can be stored since each key must be unique. You can achieve
namespacing by introducing a naming convention to the keys so different parts of
your application could operate without clashing. For example, `module1.foo` and
`module2.foo`. However, sometimes this is not very practical when the attributes
data is an array, for example a set of tokens. In this case, managing the array
becomes a burden because you have to retrieve the array then process it and
store it again::

    $tokens = array('tokens' => array('a' => 'a6c1e0b6',
                                      'b' => 'f4a7b1f3'));

So any processing of this might quickly get ugly, even simply adding a token to
the array::

    $tokens = $session->get('tokens');
    $tokens['c'] = $value;
    $session->set('tokens', $tokens);

With structured namespacing, the the key can be translated to the array
structure like this using a namespace character (defaults to `/`)::

    $session->set('tokens/c', $value);

This way you can easily access a key within the stored array directly and easily.

:class:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface`
has a simple API

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::set`:
  Sets an attribute by key;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::get`:
  Gets an attribute by key;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::all`:
  Gets all attributes as an array of key => value;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::has`:
  Returns true if the attribute exists;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::keys`:
  Returns an array of stored attribute keys;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::replace`:
  Sets multiple attributes at once: takes a keyed array and sets each key => value pair.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::remove`:
  Deletes an attribute by key;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface::clear`:
  Clear the bag;

Flash messages
~~~~~~~~~~~~~~

The purpose of the :class:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface`
is to provide a way of settings and retrieving messages on a per session basis.
The usual workflow for flash messages would be set in an request, and displayed
after a page redirect. For example, a user submits a form which hits an update
controller, and after processing the controller redirects the page to either the
updated page or an error page. Flash messages set in the previous page request
would be displayed immediately on the subsequent page load for that session.
This is however just one application for flash messages.

* :class:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\AutoExpireFlashBag`
   This implementation messages set in one page-load will
   be available for display only on the next page load. These messages will auto
   expire regardless of if they are retrieved or not.

* :class:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBag`
   In this implementation, messages will remain in the session until
   they are explicitly retrieved or cleared. This makes it possible to use ESI
   caching.

:class:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface`
has a simple API

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::set`:
  Sets a flash by type;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::get`:
  Gets a flash by type and clears the flash from the bag;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::setAll`:
  Sets an array of flashes by type => message;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::all`:
  Gets all flashes and clears the flashes from the bag;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::peek`:
  Gets a flash by type (read only);

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::peekAll`:
  Gets all flashes (read only);

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::has`:
  Returns true if the type exists;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::keys`:
  Returns an array of stored types;

* :method:`Symfony\\Component\\HttpFoundation\\Session\\Flash\\FlashBagInterface::clear`:
  Clear the bag;

Testability
-----------

Symfony2 is designed from the ground up with code-testability in mind. In order
to make your code which utilizes session easily testable we provide two separate
mock storage mechanisms for both unit testing and functional testing.

Testing code using real sessions is tricky because PHP's workflow state is global
and it is not possible to have multiple concurrent sessions in the same PHP
process.

The mock storage engines simulate the PHP session workflow without actually
starting one allowing you to test your code without complications. You may also
run multiple instances in the same PHP process.

The mock storage drivers do not read or write the system globals
`session_id()` or `session_name()`. Methods are provided to simulate this if
required:

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionStorageInterface::getId`: Gets the
  session ID.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionStorageInterface::setId`: Sets the
  session ID.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionStorageInterface::getName`: Gets the
  session name.

* :method:`Symfony\\Component\\HttpFoundation\\Session\\SessionStorageInterface::setName`: Sets the
  session name.

Unit Testing
~~~~~~~~~~~~

For unit testing where it is not necessary to persist the session, you should
simply swap out the default storage engine with
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage`::

    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockArraySessionStorage;
    use Symfony\\Component\\HttpFoundation\\Session\\Session;

    $session = new Session(new MockArraySessionStorage());

Functional Testing
~~~~~~~~~~~~~~~~~~

For functional testing where you may need to persist session data across
separate PHP processes, simply change the storage engine to
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockFileSessionStorage`::

    use Symfony\\Component\\HttpFoundation\\Session\\Session;
    use Symfony\\Component\\HttpFoundation\\Session\\Storage\\MockFileSessionStorage;

    $session = new Session(new MockFileSessionStorage());

PHP 5.4 compatibility
~~~~~~~~~~~~~~~~~~~~~

Since PHP 5.4.0, :phpclass:`SessionHandler` and :phpclass:`SessionHandlerInterface`
are available. Symfony 2.1 provides forward compatibility for the :phpclass:`SessionHandlerInterface`
so it can be used under PHP 5.3. This greatly improves inter-operability with other
libraries.

:phpclass:`SessionHandler` is a special PHP internal class which exposes native save
handlers to PHP user-space.

In order to provide a solution for those using PHP 5.4, Symfony2 has a special
class called :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeSessionHandler`
which under PHP 5.4, extends from `\SessionHandler` and under PHP 5.3 is just a
empty base class. This provides some interesting opportunities to leverage
PHP 5.4 functionality if it is available.

Save Handler Proxy
~~~~~~~~~~~~~~~~~~

There are two kinds of save handler class proxies which inherit from
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\AbstractProxy`:
they are :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeProxy`
and :class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\SessionHandlerProxy`.

:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage`
automatically injects storage handlers into a save handler proxy unless already
wrapped by one.

:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeProxy`
is used automatically under PHP 5.3 when internal PHP save handlers are specified
using the `Native*SessionHandler` classes, while
:class:`Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\SessionHandlerProxy`
will be used to wrap any custom save handlers, that implement :phpclass:`SessionHandlerInterface`.

Under PHP 5.4 and above, all session handlers implement :phpclass:`SessionHandlerInterface`
including `Native*SessionHandler` classes which inherit from :phpclass:`SessionHandler`.

The proxy mechanism allow you to get more deeply involved in session save handler
classes. A proxy for example could be used to encrypt any session transaction
without knowledge of the specific save handler.


.. _`php.net/session.customhandler`: http://php.net/session.customhandler