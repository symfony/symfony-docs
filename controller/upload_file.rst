.. index::
   single: Controller; Upload; File

How to Upload Files
===================

.. note::

    Instead of handling file uploading yourself, you may consider using the
    `VichUploaderBundle`_ community bundle. This bundle provides all the common
    operations (such as file renaming, saving and deleting) and it's tightly
    integrated with Doctrine ORM, MongoDB ODM, PHPCR ODM and Propel.

Imagine that you have a ``Product`` entity in your application and you want to
add a PDF brochure for each product. To do so, add a new property called ``brochure``
in the ``Product`` entity::

    // src/Entity/Product.php
    namespace App\Entity;

    use Doctrine\ORM\Mapping as ORM;
    use Symfony\Component\Validator\Constraints as Assert;

    class Product
    {
        // ...

        /**
         * @ORM\Column(type="string")
         *
         * @Assert\NotBlank(message="Please, upload the product brochure as a PDF file.")
         * @Assert\File(mimeTypes={ "application/pdf" })
         */
        private $brochure;

        public function getBrochure()
        {
            return $this->brochure;
        }

        public function setBrochure($brochure)
        {
            $this->brochure = $brochure;

            return $this;
        }
    }

Note that the type of the ``brochure`` column is ``string`` instead of ``binary``
or ``blob`` because it just stores the PDF file name instead of the file contents.

Then, add a new ``brochure`` field to the form that manages the ``Product`` entity::

    // src/Form/ProductType.php
    namespace App\Form;

    use App\Entity\Product;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;
    use Symfony\Component\Form\Extension\Core\Type\FileType;

    class ProductType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options)
        {
            $builder
                // ...
                ->add('brochure', FileType::class, ['label' => 'Brochure (PDF file)'])
                // ...
            ;
        }

        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Product::class,
            ]);
        }
    }

Now, update the template that renders the form to display the new ``brochure``
field (the exact template code to add depends on the method used by your application
to :doc:`customize form rendering </form/form_customization>`):

.. code-block:: html+twig

    {# templates/product/new.html.twig #}
    <h1>Adding a new product</h1>

    {{ form_start(form) }}
        {# ... #}

        {{ form_row(form.brochure) }}
    {{ form_end(form) }}

Finally, you need to update the code of the controller that handles the form::

    // src/Controller/ProductController.php
    namespace App\Controller;

    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\File\Exception\FileException;
    use Symfony\Component\HttpFoundation\Request;
    use Symfony\Component\Routing\Annotation\Route;
    use App\Entity\Product;
    use App\Form\ProductType;

    class ProductController extends AbstractController
    {
        /**
         * @Route("/product/new", name="app_product_new")
         */
        public function new(Request $request)
        {
            $product = new Product();
            $form = $this->createForm(ProductType::class, $product);
            $form->handleRequest($request);

            if ($form->isSubmitted() && $form->isValid()) {
                // $file stores the uploaded PDF file
                /** @var Symfony\Component\HttpFoundation\File\UploadedFile $file */
                $file = $product->getBrochure();

                $fileName = $this->generateUniqueFileName().'.'.$file->guessExtension();

                // Move the file to the directory where brochures are stored
                try {
                    $file->move(
                        $this->getParameter('brochures_directory'),
                        $fileName
                    );
                } catch (FileException $e) {
                    // ... handle exception if something happens during file upload
                }

                // updates the 'brochure' property to store the PDF file name
                // instead of its contents
                $product->setBrochure($fileName);

                // ... persist the $product variable or any other work

                return $this->redirect($this->generateUrl('app_product_list'));
            }

            return $this->render('product/new.html.twig', [
                'form' => $form->createView(),
            ]);
        }

        /**
         * @return string
         */
        private function generateUniqueFileName()
        {
            // md5() reduces the similarity of the file names generated by
            // uniqid(), which is based on timestamps
            return md5(uniqid());
        }
    }

Now, create the ``brochures_directory`` parameter that was used in the
controller to specify the directory in which the brochures should be stored:

.. code-block:: yaml

    # config/services.yaml

    # ...
    parameters:
        brochures_directory: '%kernel.project_dir%/public/uploads/brochures'

There are some important things to consider in the code of the above controller:

#. When the form is uploaded, the ``brochure`` property contains the whole PDF
   file contents. Since this property stores just the file name, you must set
   its new value before persisting the changes of the entity;
#. In Symfony applications, uploaded files are objects of the
   :class:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile` class. This class
   provides methods for the most common operations when dealing with uploaded files;
#. A well-known security best practice is to never trust the input provided by
   users. This also applies to the files uploaded by your visitors. The ``UploadedFile``
   class provides methods to get the original file extension
   (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getExtension`),
   the original file size (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getClientSize`)
   and the original file name (:method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getClientOriginalName`).
   However, they are considered *not safe* because a malicious user could tamper
   that information. That's why it's always better to generate a unique name and
   use the :method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::guessExtension`
   method to let Symfony guess the right extension according to the file MIME type;

.. deprecated:: 4.1

    The :method:`Symfony\\Component\\HttpFoundation\\File\\UploadedFile::getClientSize`
    method was deprecated in Symfony 4.1 and will be removed in Symfony 5.0.
    Use ``getSize()`` instead.

You can use the following code to link to the PDF brochure of a product:

.. code-block:: html+twig

    <a href="{{ asset('uploads/brochures/' ~ product.brochure) }}">View brochure (PDF)</a>

.. tip::

    When creating a form to edit an already persisted item, the file form type
    still expects a :class:`Symfony\\Component\\HttpFoundation\\File\\File`
    instance. As the persisted entity now contains only the relative file path,
    you first have to concatenate the configured upload path with the stored
    filename and create a new ``File`` class::

        use Symfony\Component\HttpFoundation\File\File;
        // ...

        $product->setBrochure(
            new File($this->getParameter('brochures_directory').'/'.$product->getBrochure())
        );

Creating an Uploader Service
----------------------------

To avoid logic in controllers, making them big, you can extract the upload
logic to a separate service::

    // src/Service/FileUploader.php
    namespace App\Service;

    use Symfony\Component\HttpFoundation\File\Exception\FileException;
    use Symfony\Component\HttpFoundation\File\UploadedFile;

    class FileUploader
    {
        private $targetDirectory;

        public function __construct($targetDirectory)
        {
            $this->targetDirectory = $targetDirectory;
        }

        public function upload(UploadedFile $file)
        {
            $fileName = md5(uniqid()).'.'.$file->guessExtension();

            try {
                $file->move($this->getTargetDirectory(), $fileName);
            } catch (FileException $e) {
                // ... handle exception if something happens during file upload
            }

            return $fileName;
        }

        public function getTargetDirectory()
        {
            return $this->targetDirectory;
        }
    }

.. tip::

    In addition to the generic :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\FileException`
    class there are other exception classes to handle failed file uploads:
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\CannotWriteFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\ExtensionFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\FormSizeFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\IniSizeFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\NoFileException`,
    :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\NoTmpDirFileException`,
    and :class:`Symfony\\Component\\HttpFoundation\\File\\Exception\\PartialFileException`.

Then, define a service for this class:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            # ...

            App\Service\FileUploader:
                arguments:
                    $targetDirectory: '%brochures_directory%'

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">
            <!-- ... -->

            <service id="App\FileUploader">
                <argument>%brochures_directory%</argument>
            </service>
        </container>

    .. code-block:: php

        // config/services.php
        use App\Service\FileUploader;

        $container->autowire(FileUploader::class)
            ->setArgument('$targetDirectory', '%brochures_directory%');

Now you're ready to use this service in the controller::

    // src/Controller/ProductController.php
    use Symfony\Component\HttpFoundation\Request;
    use App\Service\FileUploader;

    // ...
    public function new(Request $request, FileUploader $fileUploader)
    {
        // ...

        if ($form->isSubmitted() && $form->isValid()) {
            $file = $product->getBrochure();
            $fileName = $fileUploader->upload($file);

            $product->setBrochure($fileName);

            // ...
        }

        // ...
    }

Using a Doctrine Listener
-------------------------

If you are using Doctrine to store the Product entity, you can create a
:doc:`Doctrine listener </doctrine/event_listeners_subscribers>` to
automatically upload the file when persisting the entity::

    // src/EventListener/BrochureUploadListener.php
    namespace App\EventListener;

    use Symfony\Component\HttpFoundation\File\UploadedFile;
    use Symfony\Component\HttpFoundation\File\File;
    use Doctrine\ORM\Event\LifecycleEventArgs;
    use Doctrine\ORM\Event\PreUpdateEventArgs;
    use App\Entity\Product;
    use App\Service\FileUploader;

    class BrochureUploadListener
    {
        private $uploader;

        public function __construct(FileUploader $uploader)
        {
            $this->uploader = $uploader;
        }

        public function prePersist(LifecycleEventArgs $args)
        {
            $entity = $args->getEntity();

            $this->uploadFile($entity);
        }

        public function preUpdate(PreUpdateEventArgs $args)
        {
            $entity = $args->getEntity();

            $this->uploadFile($entity);
        }

        private function uploadFile($entity)
        {
            // upload only works for Product entities
            if (!$entity instanceof Product) {
                return;
            }

            $file = $entity->getBrochure();

            // only upload new files
            if ($file instanceof UploadedFile) {
                $fileName = $this->uploader->upload($file);
                $entity->setBrochure($fileName);
            } elseif ($file instanceof File) {
                // prevents the full file path being saved on updates
                // as the path is set on the postLoad listener
                $entity->setBrochure($file->getFilename());
            }
        }
    }

Now, register this class as a Doctrine listener:

.. configuration-block::

    .. code-block:: yaml

        # config/services.yaml
        services:
            _defaults:
                # ... be sure autowiring is enabled
                autowire: true
            # ...

            App\EventListener\BrochureUploadListener:
                tags:
                    - { name: doctrine.event_listener, event: prePersist }
                    - { name: doctrine.event_listener, event: preUpdate }

    .. code-block:: xml

        <!-- config/services.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>
        <container xmlns="http://symfony.com/schema/dic/services"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/dic/services
                https://symfony.com/schema/dic/services/services-1.0.xsd">

            <services>
                <!-- ... be sure autowiring is enabled -->
                <defaults autowire="true"/>
                <!-- ... -->

                <service id="App\EventListener\BrochureUploaderListener">
                    <tag name="doctrine.event_listener" event="prePersist"/>
                    <tag name="doctrine.event_listener" event="preUpdate"/>
                </service>
            </services>
        </container>

    .. code-block:: php

        // config/services.php
        use App\EventListener\BrochureUploaderListener;

        $container->autowire(BrochureUploaderListener::class)
            ->addTag('doctrine.event_listener', [
                'event' => 'prePersist',
            ])
            ->addTag('doctrine.event_listener', [
                'event' => 'preUpdate',
            ])
        ;

This listener is now automatically executed when persisting a new Product
entity. This way, you can remove everything related to uploading from the
controller.

.. tip::

    This listener can also create the ``File`` instance based on the path when
    fetching entities from the database::

        // ...
        use Symfony\Component\HttpFoundation\File\File;

        // ...
        class BrochureUploadListener
        {
            // ...

            public function postLoad(LifecycleEventArgs $args)
            {
                $entity = $args->getEntity();

                if (!$entity instanceof Product) {
                    return;
                }

                if ($fileName = $entity->getBrochure()) {
                    $entity->setBrochure(new File($this->uploader->getTargetDirectory().'/'.$fileName));
                }
            }
        }

    After adding these lines, configure the listener to also listen for the
    ``postLoad`` event.

.. _`VichUploaderBundle`: https://github.com/dustin10/VichUploaderBundle
